## 以MySQL的InnoDB存储引擎为例

### 一、事务的特性

A：原子性（Atomicity）

C：一致性（Consistency）

I：隔离性（Isolation）

D：持久性（Durability）

### 二、并行事务会引发的问题

1.脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象

2.不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。

3.幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

### 三、事务的隔离级别

- **读未提交（read uncommitted）**：指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（read committed）**：指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（repeatable read）**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（serializable ）**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

**针对不同的隔离级别，并发事务时可能发生的现象也会不同：**

| 读未提交   | 读已提交   | 可重复读 | 串行化 |
| ---------- | ---------- | -------- | ------ |
| 幻读       | 幻读       | 幻读     |        |
| 不可重复读 | 不可重复读 |          |        |
| 脏读       |            |          |        |

表格解释：

​	当事务隔离级别设置为读未提交时，所有的问题都有可能会发生

​	当事务隔离级别设置为读已提交时，有可能会发生幻读和不可重复读

​	当事务隔离级别设置为可重复读时，有可能会发生幻读

​	当事务隔离级别设置为串行化时，不会出现问题。但是会严重影响性能

**四种隔离级别的实现方式：**

​	**读未提交**：不做任何处理，直接读取最新数据即可

​	**串行化**：加读写锁的方式来处理

​	**读已提交&可重复读**：这两个都是通过创建read view来实现的。区别在于创建的时间不同。

​		读已提交：每个语句执行前，都重新生成一个read view

​		可重复读：启动事务时生成一个read view 整个事务期间都用这个read view

### 四、Read View工作方式

介绍工作方式之前，补充两个知识点。

#### 	1.MySQL-InnoDB隐藏列

​		`trx_id`：记录事务id列。当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在`trx_id` 隐藏列里

​		`roll_pointer`：undo指针。每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

#### 2.Read View数据快照

​	read view可以直接理解为数据快照，保存着数据库某个时刻的数据信息。它有四个重要字段：

- `m_ids`：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- `min_trx_id`：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- `max_trx_id`：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- `creator_trx_id`：指的是**创建该 Read View 的事务的事务 id**。	

#### 3.Read View工作方式

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 `trx_id `值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 `trx_id `值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 `trx_id `值在 Read View 的`min_trx_id`和`max_trx_id`之间，需要判断 `trx_id `是否在 `m_ids `列表中：
  - 如果记录的 `trx_id `**在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 `trx_id `**不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

### 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。



参考链接：https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84
